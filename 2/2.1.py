import torch

x = torch.arange(12)  # 创建一维张量，轴长12
print(x)
# tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
print(x.shape)  # 访问张量的形状，每个轴的长度
# torch.Size([12])
print(x.numel())  # 访问张量中元素的总数
# 12
X = x.reshape(3, 4)  # 张量形状改变，但元素值不变
# X = x.reshape(-1, 4) # 自动推断出维度，-1表示其他维度由其他元素决定
# X = x.reshape(3, -1) # 自动推断出维度，-1表示其他维度由其他元素决定
print(X)
# tensor([[ 0,  1,  2,  3],
#         [ 4,  5,  6,  7],
#         [ 8,  9, 10, 11]])
print(torch.zeros(2, 3, 4))  # 创建全零张量
# tensor([[[0., 0., 0., 0.],
#          [0., 0., 0., 0.],
#          [0., 0., 0., 0.]],
#         [[0., 0., 0., 0.],
#          [0., 0., 0., 0.],
#          [0., 0., 0., 0.]]])
print(torch.ones(2, 3, 4))  # 创建全一张量
# tensor([[[1., 1., 1., 1.],
#          [1., 1., 1., 1.],
#          [1., 1., 1., 1.]],
#
#         [[1., 1., 1., 1.],
#          [1., 1., 1., 1.],
#          [1., 1., 1., 1.]]])
print(torch.rand(3, 4))  # 创建随机张量
# tensor([[0.4100, 0.1523, 0.3693, 0.1623],
#         [0.1415, 0.7182, 0.8818, 0.9743],
#         [0.5449, 0.5448, 0.9258, 0.1914]])
print(torch.randn(3, 4))  # 创建服从正态分布的随机张量，其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样。
# tensor([[ 0.3823, -0.2671,  0.1212, -0.1859],
#         [-0.1073,  0.6807,  0.6082,  0.2897],
#         [ 0.2676,  0.2675,  0.7629, -0.0456]])
print(torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]))  # 通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值
# tensor([[2, 1, 4, 3],
#         [1, 2, 3, 4],
#         [4, 3, 2, 1]])


x = torch.tensor([1.0, 2, 4, 8])
y = torch.tensor([2, 2, 2, 2])
print(x + y, x - y, x * y, x / y, x ** y, sep="\n")  # 标准算术运算符（+、-、*、/和**）
# tensor([ 3.,  4., 16., 32.])
# tensor([-1.,  0.,  2.,  4.])
# tensor([ 2.,  4., 16., 64.])
# tensor([0.5000, 1.0000, 2.0000, 4.0000])
print(torch.exp(x))  # 计算自然对数的指数函数
# tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03])

X = torch.arange(12, dtype=torch.float32).reshape((3, 4))
Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
print(torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1), sep="\n")  # 连接两个张量 dim=0表示在行方向上连接，dim=1表示在列方向上连接
# tensor([[ 0.,  1.,  2.,  3.],
#         [ 4.,  5.,  6.,  7.],
#         [ 8.,  9., 10., 11.],
#         [ 2.,  1.,  4.,  3.],
#         [ 1.,  2.,  3.,  4.],
#         [ 4.,  3.,  2.,  1.]])
# tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],
#         [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],
#         [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]])

print(X == y)  # 按元素比较两个张量，并返回一个新的布尔张量，其中每个元素表示两个输入张量中对应的元素是否相等
# tensor([[False,  True, False, False],
#         [ True, False, False, False],
#         [False, False, False,  True]])

a = torch.arange(3).reshape((3, 1))  # 创建一维张量
b = torch.arange(2).reshape((1, 2))  # 创建一维张量
print(a, b, sep="\n")  # 打印张量a和b
# tensor([[0],
#         [1],
#         [2]])
# tensor([[0, 1]])
print(a + b)  # 由于向量形状不同，需要先将向量变形成相同的形状，矩阵a将复制列，矩阵b将复制行，然后再按元素相加。
# tensor([[0, 1],
#         [1, 2],
#         [2, 3]])

print(X[-1], X[1:3], sep="\n")  # 访问张量的元素，支持负数索引，切片操作
# tensor([ 8.,  9., 10., 11.])
# tensor([[ 4.,  5.,  6.,  7.],
#         [ 8.,  9., 10., 11.]])
X[1, 2] = 9  # 指定索引修改张量元素
print(X)
# tensor([[ 0.,  1.,  2.,  3.],
#         [ 4.,  5.,  9.,  7.],
#         [ 8.,  9., 10., 11.]])
X[0:2, :] = 12  # 为多个元素赋相同的值。访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。
print(X)
# tensor([[12., 12., 12., 12.],
#         [12., 12., 12., 12.],
#         [ 8.,  9., 10., 11.]])

Z = torch.zeros_like(Y)  # 创建与Y张量形状相同的全零张量
print(f"id(Z): {id(Z)}")  # 打印张量Z的内存地址
# id(Z): 140415247282880
Z[:] = X + Y  # 将X和Y张量中对应元素相加，并赋值给Z张量
print(f"id(Z): {id(Z)}")  # 打印张量Z的内存地址
# id(Z): 140415247282880     # 内存地址没有改变，说明Z张量是共享内存的。

before = id(X)  # 记录X张量的内存地址
X += Y  # 将X张量中对应元素相加，并赋值给X张量
print(before == id(X))
# True  # 内存地址没有改变，说明X张量是共享内存的。

A = X.numpy()  # 将张量X转换为NumPy数组
B = torch.tensor(A)  # 将NumPy数组转换为张量
print(type(A), type(B))  # 打印NumPy数组和张量的类型
# <class 'numpy.ndarray'> <class 'torch.Tensor'>

a = torch.tensor([3.5])  # 创建一维张量
print(a, a.item(), int(a), float(a), sep=", ")  # 打印张量a，item()方法可以将张量转换为Python标量，int()和float()方法可以将张量转换为整数和浮点数。
# tensor([3.5000]), 3.5, 3, 3.5
